/*
Confluent Manager for Apache Flink / CMF

Apache Flink job lifecycle management component for Confluent Platform.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

type SQLApi interface {

	/*
	CreateComputePool Creates a new Flink Compute Pool in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @return ApiCreateComputePoolRequest
	*/
	CreateComputePool(ctx _context.Context, envName string) ApiCreateComputePoolRequest

	// CreateComputePoolExecute executes the request
	//  @return ComputePool
	CreateComputePoolExecute(r ApiCreateComputePoolRequest) (ComputePool, *_nethttp.Response, error)

	/*
	CreateKafkaCatalog Creates a new Kafka Catalog that can be referenced by Flink Statements

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateKafkaCatalogRequest
	*/
	CreateKafkaCatalog(ctx _context.Context) ApiCreateKafkaCatalogRequest

	// CreateKafkaCatalogExecute executes the request
	//  @return KafkaCatalog
	CreateKafkaCatalogExecute(r ApiCreateKafkaCatalogRequest) (KafkaCatalog, *_nethttp.Response, error)

	/*
	CreateKafkaDatabase Creates a new Kafka Database

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the Catalog
	 @return ApiCreateKafkaDatabaseRequest
	*/
	CreateKafkaDatabase(ctx _context.Context, catName string) ApiCreateKafkaDatabaseRequest

	// CreateKafkaDatabaseExecute executes the request
	//  @return KafkaDatabase
	CreateKafkaDatabaseExecute(r ApiCreateKafkaDatabaseRequest) (KafkaDatabase, *_nethttp.Response, error)

	/*
	CreateStatement Creates a new Flink SQL Statement in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @return ApiCreateStatementRequest
	*/
	CreateStatement(ctx _context.Context, envName string) ApiCreateStatementRequest

	// CreateStatementExecute executes the request
	//  @return Statement
	CreateStatementExecute(r ApiCreateStatementRequest) (Statement, *_nethttp.Response, error)

	/*
	DeleteComputePool Deletes the ComputePool of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param computePoolName Name of the ComputePool
	 @return ApiDeleteComputePoolRequest
	*/
	DeleteComputePool(ctx _context.Context, envName string, computePoolName string) ApiDeleteComputePoolRequest

	// DeleteComputePoolExecute executes the request
	DeleteComputePoolExecute(r ApiDeleteComputePoolRequest) (*_nethttp.Response, error)

	/*
	DeleteKafkaCatalog Deletes the Kafka Catalog of the given name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the Kafka Catalog
	 @return ApiDeleteKafkaCatalogRequest
	*/
	DeleteKafkaCatalog(ctx _context.Context, catName string) ApiDeleteKafkaCatalogRequest

	// DeleteKafkaCatalogExecute executes the request
	DeleteKafkaCatalogExecute(r ApiDeleteKafkaCatalogRequest) (*_nethttp.Response, error)

	/*
	DeleteKafkaDatabase Deletes the Kafka Database of the given name in the given KafkaCatalog.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the Kafka Catalog
	 @param dbName Name of the Kafka Database
	 @return ApiDeleteKafkaDatabaseRequest
	*/
	DeleteKafkaDatabase(ctx _context.Context, catName string, dbName string) ApiDeleteKafkaDatabaseRequest

	// DeleteKafkaDatabaseExecute executes the request
	DeleteKafkaDatabaseExecute(r ApiDeleteKafkaDatabaseRequest) (*_nethttp.Response, error)

	/*
	DeleteStatement Deletes the Statement of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param stmtName Name of the Statement
	 @return ApiDeleteStatementRequest
	*/
	DeleteStatement(ctx _context.Context, envName string, stmtName string) ApiDeleteStatementRequest

	// DeleteStatementExecute executes the request
	DeleteStatementExecute(r ApiDeleteStatementRequest) (*_nethttp.Response, error)

	/*
	GetComputePool Retrieve the Compute Pool of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param computePoolName Name of the Compute Pool
	 @return ApiGetComputePoolRequest
	*/
	GetComputePool(ctx _context.Context, envName string, computePoolName string) ApiGetComputePoolRequest

	// GetComputePoolExecute executes the request
	//  @return ComputePool
	GetComputePoolExecute(r ApiGetComputePoolRequest) (ComputePool, *_nethttp.Response, error)

	/*
	GetComputePools Retrieve a paginated list of Compute Pools in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @return ApiGetComputePoolsRequest
	*/
	GetComputePools(ctx _context.Context, envName string) ApiGetComputePoolsRequest

	// GetComputePoolsExecute executes the request
	//  @return ComputePoolsPage
	GetComputePoolsExecute(r ApiGetComputePoolsRequest) (ComputePoolsPage, *_nethttp.Response, error)

	/*
	GetKafkaCatalog Retrieve the Kafka Catalog of the given name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the Kafka Catalog
	 @return ApiGetKafkaCatalogRequest
	*/
	GetKafkaCatalog(ctx _context.Context, catName string) ApiGetKafkaCatalogRequest

	// GetKafkaCatalogExecute executes the request
	//  @return KafkaCatalog
	GetKafkaCatalogExecute(r ApiGetKafkaCatalogRequest) (KafkaCatalog, *_nethttp.Response, error)

	/*
	GetKafkaCatalogs Retrieve a paginated list of Kafka Catalogs

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetKafkaCatalogsRequest
	*/
	GetKafkaCatalogs(ctx _context.Context) ApiGetKafkaCatalogsRequest

	// GetKafkaCatalogsExecute executes the request
	//  @return KafkaCatalogsPage
	GetKafkaCatalogsExecute(r ApiGetKafkaCatalogsRequest) (KafkaCatalogsPage, *_nethttp.Response, error)

	/*
	GetKafkaDatabase Retrieve the Kafka Database of the given name in the given KafkaCatalog.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the Kafka Catalog
	 @param dbName Name of the Kafka Database
	 @return ApiGetKafkaDatabaseRequest
	*/
	GetKafkaDatabase(ctx _context.Context, catName string, dbName string) ApiGetKafkaDatabaseRequest

	// GetKafkaDatabaseExecute executes the request
	//  @return KafkaDatabase
	GetKafkaDatabaseExecute(r ApiGetKafkaDatabaseRequest) (KafkaDatabase, *_nethttp.Response, error)

	/*
	GetKafkaDatabases Retrieve a paginated list of Kafka Databases

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the Catalog
	 @return ApiGetKafkaDatabasesRequest
	*/
	GetKafkaDatabases(ctx _context.Context, catName string) ApiGetKafkaDatabasesRequest

	// GetKafkaDatabasesExecute executes the request
	//  @return KafkaDatabasesPage
	GetKafkaDatabasesExecute(r ApiGetKafkaDatabasesRequest) (KafkaDatabasesPage, *_nethttp.Response, error)

	/*
	GetStatement Retrieve the Statement of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param stmtName Name of the Statement
	 @return ApiGetStatementRequest
	*/
	GetStatement(ctx _context.Context, envName string, stmtName string) ApiGetStatementRequest

	// GetStatementExecute executes the request
	//  @return Statement
	GetStatementExecute(r ApiGetStatementRequest) (Statement, *_nethttp.Response, error)

	/*
	GetStatementExceptions Retrieves the last 10 exceptions of the Statement with the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param stmtName Name of the Statement
	 @return ApiGetStatementExceptionsRequest
	*/
	GetStatementExceptions(ctx _context.Context, envName string, stmtName string) ApiGetStatementExceptionsRequest

	// GetStatementExceptionsExecute executes the request
	//  @return StatementExceptionList
	GetStatementExceptionsExecute(r ApiGetStatementExceptionsRequest) (StatementExceptionList, *_nethttp.Response, error)

	/*
	GetStatementResult Retrieve the result of the interactive Statement with the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param stmtName Name of the Statement
	 @return ApiGetStatementResultRequest
	*/
	GetStatementResult(ctx _context.Context, envName string, stmtName string) ApiGetStatementResultRequest

	// GetStatementResultExecute executes the request
	//  @return StatementResult
	GetStatementResultExecute(r ApiGetStatementResultRequest) (StatementResult, *_nethttp.Response, error)

	/*
	GetStatements Retrieve a paginated list of Statements in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @return ApiGetStatementsRequest
	*/
	GetStatements(ctx _context.Context, envName string) ApiGetStatementsRequest

	// GetStatementsExecute executes the request
	//  @return StatementsPage
	GetStatementsExecute(r ApiGetStatementsRequest) (StatementsPage, *_nethttp.Response, error)

	/*
	UpdateKafkaCatalog Updates a KafkaCatalog of the given name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the KafkaCatalog
	 @return ApiUpdateKafkaCatalogRequest
	*/
	UpdateKafkaCatalog(ctx _context.Context, catName string) ApiUpdateKafkaCatalogRequest

	// UpdateKafkaCatalogExecute executes the request
	UpdateKafkaCatalogExecute(r ApiUpdateKafkaCatalogRequest) (*_nethttp.Response, error)

	/*
	UpdateKafkaDatabase Updates a KafkaDatabase of the given name in the given KafkaCatalog.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param catName Name of the KafkaCatalog
	 @param dbName Name of the KafkaDatabase
	 @return ApiUpdateKafkaDatabaseRequest
	*/
	UpdateKafkaDatabase(ctx _context.Context, catName string, dbName string) ApiUpdateKafkaDatabaseRequest

	// UpdateKafkaDatabaseExecute executes the request
	UpdateKafkaDatabaseExecute(r ApiUpdateKafkaDatabaseRequest) (*_nethttp.Response, error)

	/*
	UpdateStatement Updates a Statement of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param stmtName Name of the Statement
	 @return ApiUpdateStatementRequest
	*/
	UpdateStatement(ctx _context.Context, envName string, stmtName string) ApiUpdateStatementRequest

	// UpdateStatementExecute executes the request
	UpdateStatementExecute(r ApiUpdateStatementRequest) (*_nethttp.Response, error)
}

// SQLApiService SQLApi service
type SQLApiService service

type ApiCreateComputePoolRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	computePool *ComputePool
}

func (r ApiCreateComputePoolRequest) ComputePool(computePool ComputePool) ApiCreateComputePoolRequest {
	r.computePool = &computePool
	return r
}

func (r ApiCreateComputePoolRequest) Execute() (ComputePool, *_nethttp.Response, error) {
	return r.ApiService.CreateComputePoolExecute(r)
}

/*
CreateComputePool Creates a new Flink Compute Pool in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @return ApiCreateComputePoolRequest
*/
func (a *SQLApiService) CreateComputePool(ctx _context.Context, envName string) ApiCreateComputePoolRequest {
	return ApiCreateComputePoolRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
	}
}

// Execute executes the request
//  @return ComputePool
func (a *SQLApiService) CreateComputePoolExecute(r ApiCreateComputePoolRequest) (ComputePool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ComputePool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.CreateComputePool")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/compute-pools"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computePool == nil {
		return localVarReturnValue, nil, reportError("computePool is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computePool
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateKafkaCatalogRequest struct {
	ctx _context.Context
	ApiService SQLApi
	kafkaCatalog *KafkaCatalog
}

func (r ApiCreateKafkaCatalogRequest) KafkaCatalog(kafkaCatalog KafkaCatalog) ApiCreateKafkaCatalogRequest {
	r.kafkaCatalog = &kafkaCatalog
	return r
}

func (r ApiCreateKafkaCatalogRequest) Execute() (KafkaCatalog, *_nethttp.Response, error) {
	return r.ApiService.CreateKafkaCatalogExecute(r)
}

/*
CreateKafkaCatalog Creates a new Kafka Catalog that can be referenced by Flink Statements

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateKafkaCatalogRequest
*/
func (a *SQLApiService) CreateKafkaCatalog(ctx _context.Context) ApiCreateKafkaCatalogRequest {
	return ApiCreateKafkaCatalogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KafkaCatalog
func (a *SQLApiService) CreateKafkaCatalogExecute(r ApiCreateKafkaCatalogRequest) (KafkaCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KafkaCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.CreateKafkaCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kafkaCatalog == nil {
		return localVarReturnValue, nil, reportError("kafkaCatalog is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kafkaCatalog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateKafkaDatabaseRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
	kafkaDatabase *KafkaDatabase
}

func (r ApiCreateKafkaDatabaseRequest) KafkaDatabase(kafkaDatabase KafkaDatabase) ApiCreateKafkaDatabaseRequest {
	r.kafkaDatabase = &kafkaDatabase
	return r
}

func (r ApiCreateKafkaDatabaseRequest) Execute() (KafkaDatabase, *_nethttp.Response, error) {
	return r.ApiService.CreateKafkaDatabaseExecute(r)
}

/*
CreateKafkaDatabase Creates a new Kafka Database

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the Catalog
 @return ApiCreateKafkaDatabaseRequest
*/
func (a *SQLApiService) CreateKafkaDatabase(ctx _context.Context, catName string) ApiCreateKafkaDatabaseRequest {
	return ApiCreateKafkaDatabaseRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
	}
}

// Execute executes the request
//  @return KafkaDatabase
func (a *SQLApiService) CreateKafkaDatabaseExecute(r ApiCreateKafkaDatabaseRequest) (KafkaDatabase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KafkaDatabase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.CreateKafkaDatabase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}/databases"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kafkaDatabase == nil {
		return localVarReturnValue, nil, reportError("kafkaDatabase is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kafkaDatabase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStatementRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	statement *Statement
}

func (r ApiCreateStatementRequest) Statement(statement Statement) ApiCreateStatementRequest {
	r.statement = &statement
	return r
}

func (r ApiCreateStatementRequest) Execute() (Statement, *_nethttp.Response, error) {
	return r.ApiService.CreateStatementExecute(r)
}

/*
CreateStatement Creates a new Flink SQL Statement in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @return ApiCreateStatementRequest
*/
func (a *SQLApiService) CreateStatement(ctx _context.Context, envName string) ApiCreateStatementRequest {
	return ApiCreateStatementRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
	}
}

// Execute executes the request
//  @return Statement
func (a *SQLApiService) CreateStatementExecute(r ApiCreateStatementRequest) (Statement, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Statement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.CreateStatement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.statement == nil {
		return localVarReturnValue, nil, reportError("statement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.statement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputePoolRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	computePoolName string
}


func (r ApiDeleteComputePoolRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteComputePoolExecute(r)
}

/*
DeleteComputePool Deletes the ComputePool of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param computePoolName Name of the ComputePool
 @return ApiDeleteComputePoolRequest
*/
func (a *SQLApiService) DeleteComputePool(ctx _context.Context, envName string, computePoolName string) ApiDeleteComputePoolRequest {
	return ApiDeleteComputePoolRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		computePoolName: computePoolName,
	}
}

// Execute executes the request
func (a *SQLApiService) DeleteComputePoolExecute(r ApiDeleteComputePoolRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.DeleteComputePool")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/compute-pools/{computePoolName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"computePoolName"+"}", _neturl.PathEscape(parameterToString(r.computePoolName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKafkaCatalogRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
}


func (r ApiDeleteKafkaCatalogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKafkaCatalogExecute(r)
}

/*
DeleteKafkaCatalog Deletes the Kafka Catalog of the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the Kafka Catalog
 @return ApiDeleteKafkaCatalogRequest
*/
func (a *SQLApiService) DeleteKafkaCatalog(ctx _context.Context, catName string) ApiDeleteKafkaCatalogRequest {
	return ApiDeleteKafkaCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
	}
}

// Execute executes the request
func (a *SQLApiService) DeleteKafkaCatalogExecute(r ApiDeleteKafkaCatalogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.DeleteKafkaCatalog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKafkaDatabaseRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
	dbName string
}


func (r ApiDeleteKafkaDatabaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKafkaDatabaseExecute(r)
}

/*
DeleteKafkaDatabase Deletes the Kafka Database of the given name in the given KafkaCatalog.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the Kafka Catalog
 @param dbName Name of the Kafka Database
 @return ApiDeleteKafkaDatabaseRequest
*/
func (a *SQLApiService) DeleteKafkaDatabase(ctx _context.Context, catName string, dbName string) ApiDeleteKafkaDatabaseRequest {
	return ApiDeleteKafkaDatabaseRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
		dbName: dbName,
	}
}

// Execute executes the request
func (a *SQLApiService) DeleteKafkaDatabaseExecute(r ApiDeleteKafkaDatabaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.DeleteKafkaDatabase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}/databases/{dbName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dbName"+"}", _neturl.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteStatementRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	stmtName string
}


func (r ApiDeleteStatementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteStatementExecute(r)
}

/*
DeleteStatement Deletes the Statement of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param stmtName Name of the Statement
 @return ApiDeleteStatementRequest
*/
func (a *SQLApiService) DeleteStatement(ctx _context.Context, envName string, stmtName string) ApiDeleteStatementRequest {
	return ApiDeleteStatementRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		stmtName: stmtName,
	}
}

// Execute executes the request
func (a *SQLApiService) DeleteStatementExecute(r ApiDeleteStatementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.DeleteStatement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements/{stmtName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stmtName"+"}", _neturl.PathEscape(parameterToString(r.stmtName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetComputePoolRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	computePoolName string
	includeResourceInformation *bool
}

// Whether to include resource summary in the response.
func (r ApiGetComputePoolRequest) IncludeResourceInformation(includeResourceInformation bool) ApiGetComputePoolRequest {
	r.includeResourceInformation = &includeResourceInformation
	return r
}

func (r ApiGetComputePoolRequest) Execute() (ComputePool, *_nethttp.Response, error) {
	return r.ApiService.GetComputePoolExecute(r)
}

/*
GetComputePool Retrieve the Compute Pool of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param computePoolName Name of the Compute Pool
 @return ApiGetComputePoolRequest
*/
func (a *SQLApiService) GetComputePool(ctx _context.Context, envName string, computePoolName string) ApiGetComputePoolRequest {
	return ApiGetComputePoolRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		computePoolName: computePoolName,
	}
}

// Execute executes the request
//  @return ComputePool
func (a *SQLApiService) GetComputePoolExecute(r ApiGetComputePoolRequest) (ComputePool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ComputePool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetComputePool")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/compute-pools/{computePoolName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"computePoolName"+"}", _neturl.PathEscape(parameterToString(r.computePoolName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includeResourceInformation != nil {
		localVarQueryParams.Add("include-resource-information", parameterToString(*r.includeResourceInformation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComputePoolsRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	page *int32
	size *int32
	sort *[]string
	includeResourceInformation *bool
}

// Zero-based page index (0..N)
func (r ApiGetComputePoolsRequest) Page(page int32) ApiGetComputePoolsRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetComputePoolsRequest) Size(size int32) ApiGetComputePoolsRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetComputePoolsRequest) Sort(sort []string) ApiGetComputePoolsRequest {
	r.sort = &sort
	return r
}
// Whether to include resource summary in the response.
func (r ApiGetComputePoolsRequest) IncludeResourceInformation(includeResourceInformation bool) ApiGetComputePoolsRequest {
	r.includeResourceInformation = &includeResourceInformation
	return r
}

func (r ApiGetComputePoolsRequest) Execute() (ComputePoolsPage, *_nethttp.Response, error) {
	return r.ApiService.GetComputePoolsExecute(r)
}

/*
GetComputePools Retrieve a paginated list of Compute Pools in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @return ApiGetComputePoolsRequest
*/
func (a *SQLApiService) GetComputePools(ctx _context.Context, envName string) ApiGetComputePoolsRequest {
	return ApiGetComputePoolsRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
	}
}

// Execute executes the request
//  @return ComputePoolsPage
func (a *SQLApiService) GetComputePoolsExecute(r ApiGetComputePoolsRequest) (ComputePoolsPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ComputePoolsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetComputePools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/compute-pools"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.includeResourceInformation != nil {
		localVarQueryParams.Add("include-resource-information", parameterToString(*r.includeResourceInformation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKafkaCatalogRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
}


func (r ApiGetKafkaCatalogRequest) Execute() (KafkaCatalog, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaCatalogExecute(r)
}

/*
GetKafkaCatalog Retrieve the Kafka Catalog of the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the Kafka Catalog
 @return ApiGetKafkaCatalogRequest
*/
func (a *SQLApiService) GetKafkaCatalog(ctx _context.Context, catName string) ApiGetKafkaCatalogRequest {
	return ApiGetKafkaCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
	}
}

// Execute executes the request
//  @return KafkaCatalog
func (a *SQLApiService) GetKafkaCatalogExecute(r ApiGetKafkaCatalogRequest) (KafkaCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KafkaCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetKafkaCatalog")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKafkaCatalogsRequest struct {
	ctx _context.Context
	ApiService SQLApi
	page *int32
	size *int32
	sort *[]string
}

// Zero-based page index (0..N)
func (r ApiGetKafkaCatalogsRequest) Page(page int32) ApiGetKafkaCatalogsRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetKafkaCatalogsRequest) Size(size int32) ApiGetKafkaCatalogsRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetKafkaCatalogsRequest) Sort(sort []string) ApiGetKafkaCatalogsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetKafkaCatalogsRequest) Execute() (KafkaCatalogsPage, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaCatalogsExecute(r)
}

/*
GetKafkaCatalogs Retrieve a paginated list of Kafka Catalogs

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetKafkaCatalogsRequest
*/
func (a *SQLApiService) GetKafkaCatalogs(ctx _context.Context) ApiGetKafkaCatalogsRequest {
	return ApiGetKafkaCatalogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KafkaCatalogsPage
func (a *SQLApiService) GetKafkaCatalogsExecute(r ApiGetKafkaCatalogsRequest) (KafkaCatalogsPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KafkaCatalogsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetKafkaCatalogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKafkaDatabaseRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
	dbName string
}


func (r ApiGetKafkaDatabaseRequest) Execute() (KafkaDatabase, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaDatabaseExecute(r)
}

/*
GetKafkaDatabase Retrieve the Kafka Database of the given name in the given KafkaCatalog.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the Kafka Catalog
 @param dbName Name of the Kafka Database
 @return ApiGetKafkaDatabaseRequest
*/
func (a *SQLApiService) GetKafkaDatabase(ctx _context.Context, catName string, dbName string) ApiGetKafkaDatabaseRequest {
	return ApiGetKafkaDatabaseRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
		dbName: dbName,
	}
}

// Execute executes the request
//  @return KafkaDatabase
func (a *SQLApiService) GetKafkaDatabaseExecute(r ApiGetKafkaDatabaseRequest) (KafkaDatabase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KafkaDatabase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetKafkaDatabase")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}/databases/{dbName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dbName"+"}", _neturl.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKafkaDatabasesRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
	page *int32
	size *int32
	sort *[]string
}

// Zero-based page index (0..N)
func (r ApiGetKafkaDatabasesRequest) Page(page int32) ApiGetKafkaDatabasesRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetKafkaDatabasesRequest) Size(size int32) ApiGetKafkaDatabasesRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetKafkaDatabasesRequest) Sort(sort []string) ApiGetKafkaDatabasesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetKafkaDatabasesRequest) Execute() (KafkaDatabasesPage, *_nethttp.Response, error) {
	return r.ApiService.GetKafkaDatabasesExecute(r)
}

/*
GetKafkaDatabases Retrieve a paginated list of Kafka Databases

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the Catalog
 @return ApiGetKafkaDatabasesRequest
*/
func (a *SQLApiService) GetKafkaDatabases(ctx _context.Context, catName string) ApiGetKafkaDatabasesRequest {
	return ApiGetKafkaDatabasesRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
	}
}

// Execute executes the request
//  @return KafkaDatabasesPage
func (a *SQLApiService) GetKafkaDatabasesExecute(r ApiGetKafkaDatabasesRequest) (KafkaDatabasesPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KafkaDatabasesPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetKafkaDatabases")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}/databases"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	stmtName string
	includeResourceInformation *bool
}

// Whether to include resource summary in the response.
func (r ApiGetStatementRequest) IncludeResourceInformation(includeResourceInformation bool) ApiGetStatementRequest {
	r.includeResourceInformation = &includeResourceInformation
	return r
}

func (r ApiGetStatementRequest) Execute() (Statement, *_nethttp.Response, error) {
	return r.ApiService.GetStatementExecute(r)
}

/*
GetStatement Retrieve the Statement of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param stmtName Name of the Statement
 @return ApiGetStatementRequest
*/
func (a *SQLApiService) GetStatement(ctx _context.Context, envName string, stmtName string) ApiGetStatementRequest {
	return ApiGetStatementRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		stmtName: stmtName,
	}
}

// Execute executes the request
//  @return Statement
func (a *SQLApiService) GetStatementExecute(r ApiGetStatementRequest) (Statement, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Statement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetStatement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements/{stmtName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stmtName"+"}", _neturl.PathEscape(parameterToString(r.stmtName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includeResourceInformation != nil {
		localVarQueryParams.Add("include-resource-information", parameterToString(*r.includeResourceInformation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementExceptionsRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	stmtName string
}


func (r ApiGetStatementExceptionsRequest) Execute() (StatementExceptionList, *_nethttp.Response, error) {
	return r.ApiService.GetStatementExceptionsExecute(r)
}

/*
GetStatementExceptions Retrieves the last 10 exceptions of the Statement with the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param stmtName Name of the Statement
 @return ApiGetStatementExceptionsRequest
*/
func (a *SQLApiService) GetStatementExceptions(ctx _context.Context, envName string, stmtName string) ApiGetStatementExceptionsRequest {
	return ApiGetStatementExceptionsRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		stmtName: stmtName,
	}
}

// Execute executes the request
//  @return StatementExceptionList
func (a *SQLApiService) GetStatementExceptionsExecute(r ApiGetStatementExceptionsRequest) (StatementExceptionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatementExceptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetStatementExceptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements/{stmtName}/exceptions"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stmtName"+"}", _neturl.PathEscape(parameterToString(r.stmtName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementResultRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	stmtName string
	pageToken *string
}

// Token for the next page of results
func (r ApiGetStatementResultRequest) PageToken(pageToken string) ApiGetStatementResultRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiGetStatementResultRequest) Execute() (StatementResult, *_nethttp.Response, error) {
	return r.ApiService.GetStatementResultExecute(r)
}

/*
GetStatementResult Retrieve the result of the interactive Statement with the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param stmtName Name of the Statement
 @return ApiGetStatementResultRequest
*/
func (a *SQLApiService) GetStatementResult(ctx _context.Context, envName string, stmtName string) ApiGetStatementResultRequest {
	return ApiGetStatementResultRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		stmtName: stmtName,
	}
}

// Execute executes the request
//  @return StatementResult
func (a *SQLApiService) GetStatementResultExecute(r ApiGetStatementResultRequest) (StatementResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatementResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetStatementResult")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements/{stmtName}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stmtName"+"}", _neturl.PathEscape(parameterToString(r.stmtName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageToken != nil {
		localVarQueryParams.Add("page-token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 410 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementsRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	page *int32
	size *int32
	sort *[]string
	computePool *string
	phase *string
	includeResourceInformation *bool
	name *string
}

// Zero-based page index (0..N)
func (r ApiGetStatementsRequest) Page(page int32) ApiGetStatementsRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetStatementsRequest) Size(size int32) ApiGetStatementsRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetStatementsRequest) Sort(sort []string) ApiGetStatementsRequest {
	r.sort = &sort
	return r
}
// Name of the ComputePool to filter on
func (r ApiGetStatementsRequest) ComputePool(computePool string) ApiGetStatementsRequest {
	r.computePool = &computePool
	return r
}
// Phase to filter on
func (r ApiGetStatementsRequest) Phase(phase string) ApiGetStatementsRequest {
	r.phase = &phase
	return r
}
// Whether to include resource summary in the response.
func (r ApiGetStatementsRequest) IncludeResourceInformation(includeResourceInformation bool) ApiGetStatementsRequest {
	r.includeResourceInformation = &includeResourceInformation
	return r
}
// Wildcard filter by statement name (e.g. ?name&#x3D;abc)
func (r ApiGetStatementsRequest) Name(name string) ApiGetStatementsRequest {
	r.name = &name
	return r
}

func (r ApiGetStatementsRequest) Execute() (StatementsPage, *_nethttp.Response, error) {
	return r.ApiService.GetStatementsExecute(r)
}

/*
GetStatements Retrieve a paginated list of Statements in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @return ApiGetStatementsRequest
*/
func (a *SQLApiService) GetStatements(ctx _context.Context, envName string) ApiGetStatementsRequest {
	return ApiGetStatementsRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
	}
}

// Execute executes the request
//  @return StatementsPage
func (a *SQLApiService) GetStatementsExecute(r ApiGetStatementsRequest) (StatementsPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatementsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.GetStatements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.computePool != nil {
		localVarQueryParams.Add("compute-pool", parameterToString(*r.computePool, ""))
	}
	if r.phase != nil {
		localVarQueryParams.Add("phase", parameterToString(*r.phase, ""))
	}
	if r.includeResourceInformation != nil {
		localVarQueryParams.Add("include-resource-information", parameterToString(*r.includeResourceInformation, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKafkaCatalogRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
	kafkaCatalog *KafkaCatalog
}

func (r ApiUpdateKafkaCatalogRequest) KafkaCatalog(kafkaCatalog KafkaCatalog) ApiUpdateKafkaCatalogRequest {
	r.kafkaCatalog = &kafkaCatalog
	return r
}

func (r ApiUpdateKafkaCatalogRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaCatalogExecute(r)
}

/*
UpdateKafkaCatalog Updates a KafkaCatalog of the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the KafkaCatalog
 @return ApiUpdateKafkaCatalogRequest
*/
func (a *SQLApiService) UpdateKafkaCatalog(ctx _context.Context, catName string) ApiUpdateKafkaCatalogRequest {
	return ApiUpdateKafkaCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
	}
}

// Execute executes the request
func (a *SQLApiService) UpdateKafkaCatalogExecute(r ApiUpdateKafkaCatalogRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.UpdateKafkaCatalog")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kafkaCatalog == nil {
		return nil, reportError("kafkaCatalog is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kafkaCatalog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateKafkaDatabaseRequest struct {
	ctx _context.Context
	ApiService SQLApi
	catName string
	dbName string
	kafkaDatabase *KafkaDatabase
}

func (r ApiUpdateKafkaDatabaseRequest) KafkaDatabase(kafkaDatabase KafkaDatabase) ApiUpdateKafkaDatabaseRequest {
	r.kafkaDatabase = &kafkaDatabase
	return r
}

func (r ApiUpdateKafkaDatabaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateKafkaDatabaseExecute(r)
}

/*
UpdateKafkaDatabase Updates a KafkaDatabase of the given name in the given KafkaCatalog.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catName Name of the KafkaCatalog
 @param dbName Name of the KafkaDatabase
 @return ApiUpdateKafkaDatabaseRequest
*/
func (a *SQLApiService) UpdateKafkaDatabase(ctx _context.Context, catName string, dbName string) ApiUpdateKafkaDatabaseRequest {
	return ApiUpdateKafkaDatabaseRequest{
		ApiService: a,
		ctx: ctx,
		catName: catName,
		dbName: dbName,
	}
}

// Execute executes the request
func (a *SQLApiService) UpdateKafkaDatabaseExecute(r ApiUpdateKafkaDatabaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.UpdateKafkaDatabase")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/catalogs/kafka/{catName}/databases/{dbName}"
	localVarPath = strings.Replace(localVarPath, "{"+"catName"+"}", _neturl.PathEscape(parameterToString(r.catName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dbName"+"}", _neturl.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kafkaDatabase == nil {
		return nil, reportError("kafkaDatabase is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kafkaDatabase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateStatementRequest struct {
	ctx _context.Context
	ApiService SQLApi
	envName string
	stmtName string
	statement *Statement
}

func (r ApiUpdateStatementRequest) Statement(statement Statement) ApiUpdateStatementRequest {
	r.statement = &statement
	return r
}

func (r ApiUpdateStatementRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateStatementExecute(r)
}

/*
UpdateStatement Updates a Statement of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param stmtName Name of the Statement
 @return ApiUpdateStatementRequest
*/
func (a *SQLApiService) UpdateStatement(ctx _context.Context, envName string, stmtName string) ApiUpdateStatementRequest {
	return ApiUpdateStatementRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		stmtName: stmtName,
	}
}

// Execute executes the request
func (a *SQLApiService) UpdateStatementExecute(r ApiUpdateStatementRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SQLApiService.UpdateStatement")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/statements/{stmtName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stmtName"+"}", _neturl.PathEscape(parameterToString(r.stmtName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.statement == nil {
		return nil, reportError("statement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.statement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
