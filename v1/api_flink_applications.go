/*
Confluent Manager for Apache Flink / CMF

Apache Flink job lifecycle management component for Confluent Platform.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

type FlinkApplicationsApi interface {

	/*
	CreateOrUpdateApplication Creates a new Flink Application or updates an existing one in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @return ApiCreateOrUpdateApplicationRequest
	*/
	CreateOrUpdateApplication(ctx _context.Context, envName string) ApiCreateOrUpdateApplicationRequest

	// CreateOrUpdateApplicationExecute executes the request
	//  @return FlinkApplication
	CreateOrUpdateApplicationExecute(r ApiCreateOrUpdateApplicationRequest) (FlinkApplication, *_nethttp.Response, error)

	/*
	DeleteApplication Deletes an Application of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @return ApiDeleteApplicationRequest
	*/
	DeleteApplication(ctx _context.Context, envName string, appName string) ApiDeleteApplicationRequest

	// DeleteApplicationExecute executes the request
	DeleteApplicationExecute(r ApiDeleteApplicationRequest) (*_nethttp.Response, error)

	/*
	GetApplication Retrieve an Application of the given name in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @return ApiGetApplicationRequest
	*/
	GetApplication(ctx _context.Context, envName string, appName string) ApiGetApplicationRequest

	// GetApplicationExecute executes the request
	//  @return FlinkApplication
	GetApplicationExecute(r ApiGetApplicationRequest) (FlinkApplication, *_nethttp.Response, error)

	/*
	GetApplicationEvents Get a paginated list of events of the given Application

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @return ApiGetApplicationEventsRequest
	*/
	GetApplicationEvents(ctx _context.Context, envName string, appName string) ApiGetApplicationEventsRequest

	// GetApplicationEventsExecute executes the request
	//  @return EventsPage
	GetApplicationEventsExecute(r ApiGetApplicationEventsRequest) (EventsPage, *_nethttp.Response, error)

	/*
	GetApplicationInstance Retrieve an Instance of an Application

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @param instName Name of the ApplicationInstance
	 @return ApiGetApplicationInstanceRequest
	*/
	GetApplicationInstance(ctx _context.Context, envName string, appName string, instName string) ApiGetApplicationInstanceRequest

	// GetApplicationInstanceExecute executes the request
	//  @return FlinkApplicationInstance
	GetApplicationInstanceExecute(r ApiGetApplicationInstanceRequest) (FlinkApplicationInstance, *_nethttp.Response, error)

	/*
	GetApplicationInstances Get a paginated list of instances of the given Application

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @return ApiGetApplicationInstancesRequest
	*/
	GetApplicationInstances(ctx _context.Context, envName string, appName string) ApiGetApplicationInstancesRequest

	// GetApplicationInstancesExecute executes the request
	//  @return ApplicationInstancesPage
	GetApplicationInstancesExecute(r ApiGetApplicationInstancesRequest) (ApplicationInstancesPage, *_nethttp.Response, error)

	/*
	GetApplications Retrieve a paginated list of all applications in the given Environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @return ApiGetApplicationsRequest
	*/
	GetApplications(ctx _context.Context, envName string) ApiGetApplicationsRequest

	// GetApplicationsExecute executes the request
	//  @return ApplicationsPage
	GetApplicationsExecute(r ApiGetApplicationsRequest) (ApplicationsPage, *_nethttp.Response, error)

	/*
	StartApplication Starts an earlier submitted Flink Application

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @return ApiStartApplicationRequest
	*/
	StartApplication(ctx _context.Context, envName string, appName string) ApiStartApplicationRequest

	// StartApplicationExecute executes the request
	//  @return FlinkApplication
	StartApplicationExecute(r ApiStartApplicationRequest) (FlinkApplication, *_nethttp.Response, error)

	/*
	SuspendApplication Suspends an earlier started Flink Application

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param envName Name of the Environment
	 @param appName Name of the Application
	 @return ApiSuspendApplicationRequest
	*/
	SuspendApplication(ctx _context.Context, envName string, appName string) ApiSuspendApplicationRequest

	// SuspendApplicationExecute executes the request
	//  @return FlinkApplication
	SuspendApplicationExecute(r ApiSuspendApplicationRequest) (FlinkApplication, *_nethttp.Response, error)
}

// FlinkApplicationsApiService FlinkApplicationsApi service
type FlinkApplicationsApiService service

type ApiCreateOrUpdateApplicationRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	flinkApplication *FlinkApplication
}

func (r ApiCreateOrUpdateApplicationRequest) FlinkApplication(flinkApplication FlinkApplication) ApiCreateOrUpdateApplicationRequest {
	r.flinkApplication = &flinkApplication
	return r
}

func (r ApiCreateOrUpdateApplicationRequest) Execute() (FlinkApplication, *_nethttp.Response, error) {
	return r.ApiService.CreateOrUpdateApplicationExecute(r)
}

/*
CreateOrUpdateApplication Creates a new Flink Application or updates an existing one in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @return ApiCreateOrUpdateApplicationRequest
*/
func (a *FlinkApplicationsApiService) CreateOrUpdateApplication(ctx _context.Context, envName string) ApiCreateOrUpdateApplicationRequest {
	return ApiCreateOrUpdateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
	}
}

// Execute executes the request
//  @return FlinkApplication
func (a *FlinkApplicationsApiService) CreateOrUpdateApplicationExecute(r ApiCreateOrUpdateApplicationRequest) (FlinkApplication, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlinkApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.CreateOrUpdateApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.flinkApplication == nil {
		return localVarReturnValue, nil, reportError("flinkApplication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flinkApplication
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
}


func (r ApiDeleteApplicationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteApplicationExecute(r)
}

/*
DeleteApplication Deletes an Application of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @return ApiDeleteApplicationRequest
*/
func (a *FlinkApplicationsApiService) DeleteApplication(ctx _context.Context, envName string, appName string) ApiDeleteApplicationRequest {
	return ApiDeleteApplicationRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
	}
}

// Execute executes the request
func (a *FlinkApplicationsApiService) DeleteApplicationExecute(r ApiDeleteApplicationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.DeleteApplication")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications/{appName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApplicationRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
}


func (r ApiGetApplicationRequest) Execute() (FlinkApplication, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationExecute(r)
}

/*
GetApplication Retrieve an Application of the given name in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @return ApiGetApplicationRequest
*/
func (a *FlinkApplicationsApiService) GetApplication(ctx _context.Context, envName string, appName string) ApiGetApplicationRequest {
	return ApiGetApplicationRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
	}
}

// Execute executes the request
//  @return FlinkApplication
func (a *FlinkApplicationsApiService) GetApplicationExecute(r ApiGetApplicationRequest) (FlinkApplication, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlinkApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications/{appName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationEventsRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
	page *int32
	size *int32
	sort *[]string
}

// Zero-based page index (0..N)
func (r ApiGetApplicationEventsRequest) Page(page int32) ApiGetApplicationEventsRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetApplicationEventsRequest) Size(size int32) ApiGetApplicationEventsRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetApplicationEventsRequest) Sort(sort []string) ApiGetApplicationEventsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetApplicationEventsRequest) Execute() (EventsPage, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationEventsExecute(r)
}

/*
GetApplicationEvents Get a paginated list of events of the given Application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @return ApiGetApplicationEventsRequest
*/
func (a *FlinkApplicationsApiService) GetApplicationEvents(ctx _context.Context, envName string, appName string) ApiGetApplicationEventsRequest {
	return ApiGetApplicationEventsRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
	}
}

// Execute executes the request
//  @return EventsPage
func (a *FlinkApplicationsApiService) GetApplicationEventsExecute(r ApiGetApplicationEventsRequest) (EventsPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EventsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.GetApplicationEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1alpha1/environments/{envName}/applications/{appName}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationInstanceRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
	instName string
}


func (r ApiGetApplicationInstanceRequest) Execute() (FlinkApplicationInstance, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationInstanceExecute(r)
}

/*
GetApplicationInstance Retrieve an Instance of an Application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @param instName Name of the ApplicationInstance
 @return ApiGetApplicationInstanceRequest
*/
func (a *FlinkApplicationsApiService) GetApplicationInstance(ctx _context.Context, envName string, appName string, instName string) ApiGetApplicationInstanceRequest {
	return ApiGetApplicationInstanceRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
		instName: instName,
	}
}

// Execute executes the request
//  @return FlinkApplicationInstance
func (a *FlinkApplicationsApiService) GetApplicationInstanceExecute(r ApiGetApplicationInstanceRequest) (FlinkApplicationInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlinkApplicationInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.GetApplicationInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications/{appName}/instances/{instName}"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instName"+"}", _neturl.PathEscape(parameterToString(r.instName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationInstancesRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
	page *int32
	size *int32
	sort *[]string
}

// Zero-based page index (0..N)
func (r ApiGetApplicationInstancesRequest) Page(page int32) ApiGetApplicationInstancesRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetApplicationInstancesRequest) Size(size int32) ApiGetApplicationInstancesRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetApplicationInstancesRequest) Sort(sort []string) ApiGetApplicationInstancesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetApplicationInstancesRequest) Execute() (ApplicationInstancesPage, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationInstancesExecute(r)
}

/*
GetApplicationInstances Get a paginated list of instances of the given Application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @return ApiGetApplicationInstancesRequest
*/
func (a *FlinkApplicationsApiService) GetApplicationInstances(ctx _context.Context, envName string, appName string) ApiGetApplicationInstancesRequest {
	return ApiGetApplicationInstancesRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
	}
}

// Execute executes the request
//  @return ApplicationInstancesPage
func (a *FlinkApplicationsApiService) GetApplicationInstancesExecute(r ApiGetApplicationInstancesRequest) (ApplicationInstancesPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationInstancesPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.GetApplicationInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications/{appName}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationsRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	page *int32
	size *int32
	sort *[]string
}

// Zero-based page index (0..N)
func (r ApiGetApplicationsRequest) Page(page int32) ApiGetApplicationsRequest {
	r.page = &page
	return r
}
// The size of the page to be returned
func (r ApiGetApplicationsRequest) Size(size int32) ApiGetApplicationsRequest {
	r.size = &size
	return r
}
// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetApplicationsRequest) Sort(sort []string) ApiGetApplicationsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetApplicationsRequest) Execute() (ApplicationsPage, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationsExecute(r)
}

/*
GetApplications Retrieve a paginated list of all applications in the given Environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @return ApiGetApplicationsRequest
*/
func (a *FlinkApplicationsApiService) GetApplications(ctx _context.Context, envName string) ApiGetApplicationsRequest {
	return ApiGetApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
	}
}

// Execute executes the request
//  @return ApplicationsPage
func (a *FlinkApplicationsApiService) GetApplicationsExecute(r ApiGetApplicationsRequest) (ApplicationsPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationsPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.GetApplications")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartApplicationRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
	startFromSavepointUid *string
}

// UID of the Savepoint from which the application should be started. This savepoint could belong to the application or can be a deatched savepoint.
func (r ApiStartApplicationRequest) StartFromSavepointUid(startFromSavepointUid string) ApiStartApplicationRequest {
	r.startFromSavepointUid = &startFromSavepointUid
	return r
}

func (r ApiStartApplicationRequest) Execute() (FlinkApplication, *_nethttp.Response, error) {
	return r.ApiService.StartApplicationExecute(r)
}

/*
StartApplication Starts an earlier submitted Flink Application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @return ApiStartApplicationRequest
*/
func (a *FlinkApplicationsApiService) StartApplication(ctx _context.Context, envName string, appName string) ApiStartApplicationRequest {
	return ApiStartApplicationRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
	}
}

// Execute executes the request
//  @return FlinkApplication
func (a *FlinkApplicationsApiService) StartApplicationExecute(r ApiStartApplicationRequest) (FlinkApplication, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlinkApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.StartApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications/{appName}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startFromSavepointUid != nil {
		localVarQueryParams.Add("startFromSavepointUid", parameterToString(*r.startFromSavepointUid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendApplicationRequest struct {
	ctx _context.Context
	ApiService FlinkApplicationsApi
	envName string
	appName string
}


func (r ApiSuspendApplicationRequest) Execute() (FlinkApplication, *_nethttp.Response, error) {
	return r.ApiService.SuspendApplicationExecute(r)
}

/*
SuspendApplication Suspends an earlier started Flink Application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param envName Name of the Environment
 @param appName Name of the Application
 @return ApiSuspendApplicationRequest
*/
func (a *FlinkApplicationsApiService) SuspendApplication(ctx _context.Context, envName string, appName string) ApiSuspendApplicationRequest {
	return ApiSuspendApplicationRequest{
		ApiService: a,
		ctx: ctx,
		envName: envName,
		appName: appName,
	}
}

// Execute executes the request
//  @return FlinkApplication
func (a *FlinkApplicationsApiService) SuspendApplicationExecute(r ApiSuspendApplicationRequest) (FlinkApplication, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlinkApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlinkApplicationsApiService.SuspendApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cmf/api/v1/environments/{envName}/applications/{appName}/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"envName"+"}", _neturl.PathEscape(parameterToString(r.envName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", _neturl.PathEscape(parameterToString(r.appName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
