// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: api_flink_applications.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_cmf_sdk_go_v1 "github.com/confluentinc/cmf-sdk-go/v1"
)

// MockFlinkApplicationsApi is a mock of FlinkApplicationsApi interface
type MockFlinkApplicationsApi struct {
	lockCreateOrUpdateApplication sync.Mutex
	CreateOrUpdateApplicationFunc func(ctx context.Context, envName string) github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest

	lockCreateOrUpdateApplicationExecute sync.Mutex
	CreateOrUpdateApplicationExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error)

	lockDeleteApplication sync.Mutex
	DeleteApplicationFunc func(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest

	lockDeleteApplicationExecute sync.Mutex
	DeleteApplicationExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest) (*net_http.Response, error)

	lockGetApplication sync.Mutex
	GetApplicationFunc func(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest

	lockGetApplicationExecute sync.Mutex
	GetApplicationExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error)

	lockGetApplicationEvents sync.Mutex
	GetApplicationEventsFunc func(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest

	lockGetApplicationEventsExecute sync.Mutex
	GetApplicationEventsExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest) (github_com_confluentinc_cmf_sdk_go_v1.EventsPage, *net_http.Response, error)

	lockGetApplicationInstance sync.Mutex
	GetApplicationInstanceFunc func(ctx context.Context, envName, appName, instName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest

	lockGetApplicationInstanceExecute sync.Mutex
	GetApplicationInstanceExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplicationInstance, *net_http.Response, error)

	lockGetApplicationInstances sync.Mutex
	GetApplicationInstancesFunc func(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest

	lockGetApplicationInstancesExecute sync.Mutex
	GetApplicationInstancesExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest) (github_com_confluentinc_cmf_sdk_go_v1.ApplicationInstancesPage, *net_http.Response, error)

	lockGetApplications sync.Mutex
	GetApplicationsFunc func(ctx context.Context, envName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest

	lockGetApplicationsExecute sync.Mutex
	GetApplicationsExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest) (github_com_confluentinc_cmf_sdk_go_v1.ApplicationsPage, *net_http.Response, error)

	lockStartApplication sync.Mutex
	StartApplicationFunc func(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest

	lockStartApplicationExecute sync.Mutex
	StartApplicationExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error)

	lockSuspendApplication sync.Mutex
	SuspendApplicationFunc func(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest

	lockSuspendApplicationExecute sync.Mutex
	SuspendApplicationExecuteFunc func(r github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error)

	calls struct {
		CreateOrUpdateApplication []struct {
			Ctx     context.Context
			EnvName string
		}
		CreateOrUpdateApplicationExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest
		}
		DeleteApplication []struct {
			Ctx     context.Context
			EnvName string
			AppName string
		}
		DeleteApplicationExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest
		}
		GetApplication []struct {
			Ctx     context.Context
			EnvName string
			AppName string
		}
		GetApplicationExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest
		}
		GetApplicationEvents []struct {
			Ctx     context.Context
			EnvName string
			AppName string
		}
		GetApplicationEventsExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest
		}
		GetApplicationInstance []struct {
			Ctx      context.Context
			EnvName  string
			AppName  string
			InstName string
		}
		GetApplicationInstanceExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest
		}
		GetApplicationInstances []struct {
			Ctx     context.Context
			EnvName string
			AppName string
		}
		GetApplicationInstancesExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest
		}
		GetApplications []struct {
			Ctx     context.Context
			EnvName string
		}
		GetApplicationsExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest
		}
		StartApplication []struct {
			Ctx     context.Context
			EnvName string
			AppName string
		}
		StartApplicationExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest
		}
		SuspendApplication []struct {
			Ctx     context.Context
			EnvName string
			AppName string
		}
		SuspendApplicationExecute []struct {
			R github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest
		}
	}
}

// CreateOrUpdateApplication mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) CreateOrUpdateApplication(ctx context.Context, envName string) github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest {
	m.lockCreateOrUpdateApplication.Lock()
	defer m.lockCreateOrUpdateApplication.Unlock()

	if m.CreateOrUpdateApplicationFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.CreateOrUpdateApplicationFunc is nil but MockFlinkApplicationsApi.CreateOrUpdateApplication was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
	}{
		Ctx:     ctx,
		EnvName: envName,
	}

	m.calls.CreateOrUpdateApplication = append(m.calls.CreateOrUpdateApplication, call)

	return m.CreateOrUpdateApplicationFunc(ctx, envName)
}

// CreateOrUpdateApplicationCalled returns true if CreateOrUpdateApplication was called at least once.
func (m *MockFlinkApplicationsApi) CreateOrUpdateApplicationCalled() bool {
	m.lockCreateOrUpdateApplication.Lock()
	defer m.lockCreateOrUpdateApplication.Unlock()

	return len(m.calls.CreateOrUpdateApplication) > 0
}

// CreateOrUpdateApplicationCalls returns the calls made to CreateOrUpdateApplication.
func (m *MockFlinkApplicationsApi) CreateOrUpdateApplicationCalls() []struct {
	Ctx     context.Context
	EnvName string
} {
	m.lockCreateOrUpdateApplication.Lock()
	defer m.lockCreateOrUpdateApplication.Unlock()

	return m.calls.CreateOrUpdateApplication
}

// CreateOrUpdateApplicationExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) CreateOrUpdateApplicationExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error) {
	m.lockCreateOrUpdateApplicationExecute.Lock()
	defer m.lockCreateOrUpdateApplicationExecute.Unlock()

	if m.CreateOrUpdateApplicationExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.CreateOrUpdateApplicationExecuteFunc is nil but MockFlinkApplicationsApi.CreateOrUpdateApplicationExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest
	}{
		R: r,
	}

	m.calls.CreateOrUpdateApplicationExecute = append(m.calls.CreateOrUpdateApplicationExecute, call)

	return m.CreateOrUpdateApplicationExecuteFunc(r)
}

// CreateOrUpdateApplicationExecuteCalled returns true if CreateOrUpdateApplicationExecute was called at least once.
func (m *MockFlinkApplicationsApi) CreateOrUpdateApplicationExecuteCalled() bool {
	m.lockCreateOrUpdateApplicationExecute.Lock()
	defer m.lockCreateOrUpdateApplicationExecute.Unlock()

	return len(m.calls.CreateOrUpdateApplicationExecute) > 0
}

// CreateOrUpdateApplicationExecuteCalls returns the calls made to CreateOrUpdateApplicationExecute.
func (m *MockFlinkApplicationsApi) CreateOrUpdateApplicationExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiCreateOrUpdateApplicationRequest
} {
	m.lockCreateOrUpdateApplicationExecute.Lock()
	defer m.lockCreateOrUpdateApplicationExecute.Unlock()

	return m.calls.CreateOrUpdateApplicationExecute
}

// DeleteApplication mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) DeleteApplication(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest {
	m.lockDeleteApplication.Lock()
	defer m.lockDeleteApplication.Unlock()

	if m.DeleteApplicationFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.DeleteApplicationFunc is nil but MockFlinkApplicationsApi.DeleteApplication was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
		AppName string
	}{
		Ctx:     ctx,
		EnvName: envName,
		AppName: appName,
	}

	m.calls.DeleteApplication = append(m.calls.DeleteApplication, call)

	return m.DeleteApplicationFunc(ctx, envName, appName)
}

// DeleteApplicationCalled returns true if DeleteApplication was called at least once.
func (m *MockFlinkApplicationsApi) DeleteApplicationCalled() bool {
	m.lockDeleteApplication.Lock()
	defer m.lockDeleteApplication.Unlock()

	return len(m.calls.DeleteApplication) > 0
}

// DeleteApplicationCalls returns the calls made to DeleteApplication.
func (m *MockFlinkApplicationsApi) DeleteApplicationCalls() []struct {
	Ctx     context.Context
	EnvName string
	AppName string
} {
	m.lockDeleteApplication.Lock()
	defer m.lockDeleteApplication.Unlock()

	return m.calls.DeleteApplication
}

// DeleteApplicationExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) DeleteApplicationExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest) (*net_http.Response, error) {
	m.lockDeleteApplicationExecute.Lock()
	defer m.lockDeleteApplicationExecute.Unlock()

	if m.DeleteApplicationExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.DeleteApplicationExecuteFunc is nil but MockFlinkApplicationsApi.DeleteApplicationExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest
	}{
		R: r,
	}

	m.calls.DeleteApplicationExecute = append(m.calls.DeleteApplicationExecute, call)

	return m.DeleteApplicationExecuteFunc(r)
}

// DeleteApplicationExecuteCalled returns true if DeleteApplicationExecute was called at least once.
func (m *MockFlinkApplicationsApi) DeleteApplicationExecuteCalled() bool {
	m.lockDeleteApplicationExecute.Lock()
	defer m.lockDeleteApplicationExecute.Unlock()

	return len(m.calls.DeleteApplicationExecute) > 0
}

// DeleteApplicationExecuteCalls returns the calls made to DeleteApplicationExecute.
func (m *MockFlinkApplicationsApi) DeleteApplicationExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiDeleteApplicationRequest
} {
	m.lockDeleteApplicationExecute.Lock()
	defer m.lockDeleteApplicationExecute.Unlock()

	return m.calls.DeleteApplicationExecute
}

// GetApplication mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplication(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest {
	m.lockGetApplication.Lock()
	defer m.lockGetApplication.Unlock()

	if m.GetApplicationFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationFunc is nil but MockFlinkApplicationsApi.GetApplication was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
		AppName string
	}{
		Ctx:     ctx,
		EnvName: envName,
		AppName: appName,
	}

	m.calls.GetApplication = append(m.calls.GetApplication, call)

	return m.GetApplicationFunc(ctx, envName, appName)
}

// GetApplicationCalled returns true if GetApplication was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationCalled() bool {
	m.lockGetApplication.Lock()
	defer m.lockGetApplication.Unlock()

	return len(m.calls.GetApplication) > 0
}

// GetApplicationCalls returns the calls made to GetApplication.
func (m *MockFlinkApplicationsApi) GetApplicationCalls() []struct {
	Ctx     context.Context
	EnvName string
	AppName string
} {
	m.lockGetApplication.Lock()
	defer m.lockGetApplication.Unlock()

	return m.calls.GetApplication
}

// GetApplicationExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error) {
	m.lockGetApplicationExecute.Lock()
	defer m.lockGetApplicationExecute.Unlock()

	if m.GetApplicationExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationExecuteFunc is nil but MockFlinkApplicationsApi.GetApplicationExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest
	}{
		R: r,
	}

	m.calls.GetApplicationExecute = append(m.calls.GetApplicationExecute, call)

	return m.GetApplicationExecuteFunc(r)
}

// GetApplicationExecuteCalled returns true if GetApplicationExecute was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationExecuteCalled() bool {
	m.lockGetApplicationExecute.Lock()
	defer m.lockGetApplicationExecute.Unlock()

	return len(m.calls.GetApplicationExecute) > 0
}

// GetApplicationExecuteCalls returns the calls made to GetApplicationExecute.
func (m *MockFlinkApplicationsApi) GetApplicationExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationRequest
} {
	m.lockGetApplicationExecute.Lock()
	defer m.lockGetApplicationExecute.Unlock()

	return m.calls.GetApplicationExecute
}

// GetApplicationEvents mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationEvents(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest {
	m.lockGetApplicationEvents.Lock()
	defer m.lockGetApplicationEvents.Unlock()

	if m.GetApplicationEventsFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationEventsFunc is nil but MockFlinkApplicationsApi.GetApplicationEvents was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
		AppName string
	}{
		Ctx:     ctx,
		EnvName: envName,
		AppName: appName,
	}

	m.calls.GetApplicationEvents = append(m.calls.GetApplicationEvents, call)

	return m.GetApplicationEventsFunc(ctx, envName, appName)
}

// GetApplicationEventsCalled returns true if GetApplicationEvents was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationEventsCalled() bool {
	m.lockGetApplicationEvents.Lock()
	defer m.lockGetApplicationEvents.Unlock()

	return len(m.calls.GetApplicationEvents) > 0
}

// GetApplicationEventsCalls returns the calls made to GetApplicationEvents.
func (m *MockFlinkApplicationsApi) GetApplicationEventsCalls() []struct {
	Ctx     context.Context
	EnvName string
	AppName string
} {
	m.lockGetApplicationEvents.Lock()
	defer m.lockGetApplicationEvents.Unlock()

	return m.calls.GetApplicationEvents
}

// GetApplicationEventsExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationEventsExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest) (github_com_confluentinc_cmf_sdk_go_v1.EventsPage, *net_http.Response, error) {
	m.lockGetApplicationEventsExecute.Lock()
	defer m.lockGetApplicationEventsExecute.Unlock()

	if m.GetApplicationEventsExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationEventsExecuteFunc is nil but MockFlinkApplicationsApi.GetApplicationEventsExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest
	}{
		R: r,
	}

	m.calls.GetApplicationEventsExecute = append(m.calls.GetApplicationEventsExecute, call)

	return m.GetApplicationEventsExecuteFunc(r)
}

// GetApplicationEventsExecuteCalled returns true if GetApplicationEventsExecute was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationEventsExecuteCalled() bool {
	m.lockGetApplicationEventsExecute.Lock()
	defer m.lockGetApplicationEventsExecute.Unlock()

	return len(m.calls.GetApplicationEventsExecute) > 0
}

// GetApplicationEventsExecuteCalls returns the calls made to GetApplicationEventsExecute.
func (m *MockFlinkApplicationsApi) GetApplicationEventsExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationEventsRequest
} {
	m.lockGetApplicationEventsExecute.Lock()
	defer m.lockGetApplicationEventsExecute.Unlock()

	return m.calls.GetApplicationEventsExecute
}

// GetApplicationInstance mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationInstance(ctx context.Context, envName, appName, instName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest {
	m.lockGetApplicationInstance.Lock()
	defer m.lockGetApplicationInstance.Unlock()

	if m.GetApplicationInstanceFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationInstanceFunc is nil but MockFlinkApplicationsApi.GetApplicationInstance was called.")
	}

	call := struct {
		Ctx      context.Context
		EnvName  string
		AppName  string
		InstName string
	}{
		Ctx:      ctx,
		EnvName:  envName,
		AppName:  appName,
		InstName: instName,
	}

	m.calls.GetApplicationInstance = append(m.calls.GetApplicationInstance, call)

	return m.GetApplicationInstanceFunc(ctx, envName, appName, instName)
}

// GetApplicationInstanceCalled returns true if GetApplicationInstance was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationInstanceCalled() bool {
	m.lockGetApplicationInstance.Lock()
	defer m.lockGetApplicationInstance.Unlock()

	return len(m.calls.GetApplicationInstance) > 0
}

// GetApplicationInstanceCalls returns the calls made to GetApplicationInstance.
func (m *MockFlinkApplicationsApi) GetApplicationInstanceCalls() []struct {
	Ctx      context.Context
	EnvName  string
	AppName  string
	InstName string
} {
	m.lockGetApplicationInstance.Lock()
	defer m.lockGetApplicationInstance.Unlock()

	return m.calls.GetApplicationInstance
}

// GetApplicationInstanceExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationInstanceExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplicationInstance, *net_http.Response, error) {
	m.lockGetApplicationInstanceExecute.Lock()
	defer m.lockGetApplicationInstanceExecute.Unlock()

	if m.GetApplicationInstanceExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationInstanceExecuteFunc is nil but MockFlinkApplicationsApi.GetApplicationInstanceExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest
	}{
		R: r,
	}

	m.calls.GetApplicationInstanceExecute = append(m.calls.GetApplicationInstanceExecute, call)

	return m.GetApplicationInstanceExecuteFunc(r)
}

// GetApplicationInstanceExecuteCalled returns true if GetApplicationInstanceExecute was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationInstanceExecuteCalled() bool {
	m.lockGetApplicationInstanceExecute.Lock()
	defer m.lockGetApplicationInstanceExecute.Unlock()

	return len(m.calls.GetApplicationInstanceExecute) > 0
}

// GetApplicationInstanceExecuteCalls returns the calls made to GetApplicationInstanceExecute.
func (m *MockFlinkApplicationsApi) GetApplicationInstanceExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstanceRequest
} {
	m.lockGetApplicationInstanceExecute.Lock()
	defer m.lockGetApplicationInstanceExecute.Unlock()

	return m.calls.GetApplicationInstanceExecute
}

// GetApplicationInstances mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationInstances(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest {
	m.lockGetApplicationInstances.Lock()
	defer m.lockGetApplicationInstances.Unlock()

	if m.GetApplicationInstancesFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationInstancesFunc is nil but MockFlinkApplicationsApi.GetApplicationInstances was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
		AppName string
	}{
		Ctx:     ctx,
		EnvName: envName,
		AppName: appName,
	}

	m.calls.GetApplicationInstances = append(m.calls.GetApplicationInstances, call)

	return m.GetApplicationInstancesFunc(ctx, envName, appName)
}

// GetApplicationInstancesCalled returns true if GetApplicationInstances was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationInstancesCalled() bool {
	m.lockGetApplicationInstances.Lock()
	defer m.lockGetApplicationInstances.Unlock()

	return len(m.calls.GetApplicationInstances) > 0
}

// GetApplicationInstancesCalls returns the calls made to GetApplicationInstances.
func (m *MockFlinkApplicationsApi) GetApplicationInstancesCalls() []struct {
	Ctx     context.Context
	EnvName string
	AppName string
} {
	m.lockGetApplicationInstances.Lock()
	defer m.lockGetApplicationInstances.Unlock()

	return m.calls.GetApplicationInstances
}

// GetApplicationInstancesExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationInstancesExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest) (github_com_confluentinc_cmf_sdk_go_v1.ApplicationInstancesPage, *net_http.Response, error) {
	m.lockGetApplicationInstancesExecute.Lock()
	defer m.lockGetApplicationInstancesExecute.Unlock()

	if m.GetApplicationInstancesExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationInstancesExecuteFunc is nil but MockFlinkApplicationsApi.GetApplicationInstancesExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest
	}{
		R: r,
	}

	m.calls.GetApplicationInstancesExecute = append(m.calls.GetApplicationInstancesExecute, call)

	return m.GetApplicationInstancesExecuteFunc(r)
}

// GetApplicationInstancesExecuteCalled returns true if GetApplicationInstancesExecute was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationInstancesExecuteCalled() bool {
	m.lockGetApplicationInstancesExecute.Lock()
	defer m.lockGetApplicationInstancesExecute.Unlock()

	return len(m.calls.GetApplicationInstancesExecute) > 0
}

// GetApplicationInstancesExecuteCalls returns the calls made to GetApplicationInstancesExecute.
func (m *MockFlinkApplicationsApi) GetApplicationInstancesExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationInstancesRequest
} {
	m.lockGetApplicationInstancesExecute.Lock()
	defer m.lockGetApplicationInstancesExecute.Unlock()

	return m.calls.GetApplicationInstancesExecute
}

// GetApplications mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplications(ctx context.Context, envName string) github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest {
	m.lockGetApplications.Lock()
	defer m.lockGetApplications.Unlock()

	if m.GetApplicationsFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationsFunc is nil but MockFlinkApplicationsApi.GetApplications was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
	}{
		Ctx:     ctx,
		EnvName: envName,
	}

	m.calls.GetApplications = append(m.calls.GetApplications, call)

	return m.GetApplicationsFunc(ctx, envName)
}

// GetApplicationsCalled returns true if GetApplications was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationsCalled() bool {
	m.lockGetApplications.Lock()
	defer m.lockGetApplications.Unlock()

	return len(m.calls.GetApplications) > 0
}

// GetApplicationsCalls returns the calls made to GetApplications.
func (m *MockFlinkApplicationsApi) GetApplicationsCalls() []struct {
	Ctx     context.Context
	EnvName string
} {
	m.lockGetApplications.Lock()
	defer m.lockGetApplications.Unlock()

	return m.calls.GetApplications
}

// GetApplicationsExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) GetApplicationsExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest) (github_com_confluentinc_cmf_sdk_go_v1.ApplicationsPage, *net_http.Response, error) {
	m.lockGetApplicationsExecute.Lock()
	defer m.lockGetApplicationsExecute.Unlock()

	if m.GetApplicationsExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.GetApplicationsExecuteFunc is nil but MockFlinkApplicationsApi.GetApplicationsExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest
	}{
		R: r,
	}

	m.calls.GetApplicationsExecute = append(m.calls.GetApplicationsExecute, call)

	return m.GetApplicationsExecuteFunc(r)
}

// GetApplicationsExecuteCalled returns true if GetApplicationsExecute was called at least once.
func (m *MockFlinkApplicationsApi) GetApplicationsExecuteCalled() bool {
	m.lockGetApplicationsExecute.Lock()
	defer m.lockGetApplicationsExecute.Unlock()

	return len(m.calls.GetApplicationsExecute) > 0
}

// GetApplicationsExecuteCalls returns the calls made to GetApplicationsExecute.
func (m *MockFlinkApplicationsApi) GetApplicationsExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiGetApplicationsRequest
} {
	m.lockGetApplicationsExecute.Lock()
	defer m.lockGetApplicationsExecute.Unlock()

	return m.calls.GetApplicationsExecute
}

// StartApplication mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) StartApplication(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest {
	m.lockStartApplication.Lock()
	defer m.lockStartApplication.Unlock()

	if m.StartApplicationFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.StartApplicationFunc is nil but MockFlinkApplicationsApi.StartApplication was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
		AppName string
	}{
		Ctx:     ctx,
		EnvName: envName,
		AppName: appName,
	}

	m.calls.StartApplication = append(m.calls.StartApplication, call)

	return m.StartApplicationFunc(ctx, envName, appName)
}

// StartApplicationCalled returns true if StartApplication was called at least once.
func (m *MockFlinkApplicationsApi) StartApplicationCalled() bool {
	m.lockStartApplication.Lock()
	defer m.lockStartApplication.Unlock()

	return len(m.calls.StartApplication) > 0
}

// StartApplicationCalls returns the calls made to StartApplication.
func (m *MockFlinkApplicationsApi) StartApplicationCalls() []struct {
	Ctx     context.Context
	EnvName string
	AppName string
} {
	m.lockStartApplication.Lock()
	defer m.lockStartApplication.Unlock()

	return m.calls.StartApplication
}

// StartApplicationExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) StartApplicationExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error) {
	m.lockStartApplicationExecute.Lock()
	defer m.lockStartApplicationExecute.Unlock()

	if m.StartApplicationExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.StartApplicationExecuteFunc is nil but MockFlinkApplicationsApi.StartApplicationExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest
	}{
		R: r,
	}

	m.calls.StartApplicationExecute = append(m.calls.StartApplicationExecute, call)

	return m.StartApplicationExecuteFunc(r)
}

// StartApplicationExecuteCalled returns true if StartApplicationExecute was called at least once.
func (m *MockFlinkApplicationsApi) StartApplicationExecuteCalled() bool {
	m.lockStartApplicationExecute.Lock()
	defer m.lockStartApplicationExecute.Unlock()

	return len(m.calls.StartApplicationExecute) > 0
}

// StartApplicationExecuteCalls returns the calls made to StartApplicationExecute.
func (m *MockFlinkApplicationsApi) StartApplicationExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiStartApplicationRequest
} {
	m.lockStartApplicationExecute.Lock()
	defer m.lockStartApplicationExecute.Unlock()

	return m.calls.StartApplicationExecute
}

// SuspendApplication mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) SuspendApplication(ctx context.Context, envName, appName string) github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest {
	m.lockSuspendApplication.Lock()
	defer m.lockSuspendApplication.Unlock()

	if m.SuspendApplicationFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.SuspendApplicationFunc is nil but MockFlinkApplicationsApi.SuspendApplication was called.")
	}

	call := struct {
		Ctx     context.Context
		EnvName string
		AppName string
	}{
		Ctx:     ctx,
		EnvName: envName,
		AppName: appName,
	}

	m.calls.SuspendApplication = append(m.calls.SuspendApplication, call)

	return m.SuspendApplicationFunc(ctx, envName, appName)
}

// SuspendApplicationCalled returns true if SuspendApplication was called at least once.
func (m *MockFlinkApplicationsApi) SuspendApplicationCalled() bool {
	m.lockSuspendApplication.Lock()
	defer m.lockSuspendApplication.Unlock()

	return len(m.calls.SuspendApplication) > 0
}

// SuspendApplicationCalls returns the calls made to SuspendApplication.
func (m *MockFlinkApplicationsApi) SuspendApplicationCalls() []struct {
	Ctx     context.Context
	EnvName string
	AppName string
} {
	m.lockSuspendApplication.Lock()
	defer m.lockSuspendApplication.Unlock()

	return m.calls.SuspendApplication
}

// SuspendApplicationExecute mocks base method by wrapping the associated func.
func (m *MockFlinkApplicationsApi) SuspendApplicationExecute(r github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest) (github_com_confluentinc_cmf_sdk_go_v1.FlinkApplication, *net_http.Response, error) {
	m.lockSuspendApplicationExecute.Lock()
	defer m.lockSuspendApplicationExecute.Unlock()

	if m.SuspendApplicationExecuteFunc == nil {
		panic("mocker: MockFlinkApplicationsApi.SuspendApplicationExecuteFunc is nil but MockFlinkApplicationsApi.SuspendApplicationExecute was called.")
	}

	call := struct {
		R github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest
	}{
		R: r,
	}

	m.calls.SuspendApplicationExecute = append(m.calls.SuspendApplicationExecute, call)

	return m.SuspendApplicationExecuteFunc(r)
}

// SuspendApplicationExecuteCalled returns true if SuspendApplicationExecute was called at least once.
func (m *MockFlinkApplicationsApi) SuspendApplicationExecuteCalled() bool {
	m.lockSuspendApplicationExecute.Lock()
	defer m.lockSuspendApplicationExecute.Unlock()

	return len(m.calls.SuspendApplicationExecute) > 0
}

// SuspendApplicationExecuteCalls returns the calls made to SuspendApplicationExecute.
func (m *MockFlinkApplicationsApi) SuspendApplicationExecuteCalls() []struct {
	R github_com_confluentinc_cmf_sdk_go_v1.ApiSuspendApplicationRequest
} {
	m.lockSuspendApplicationExecute.Lock()
	defer m.lockSuspendApplicationExecute.Unlock()

	return m.calls.SuspendApplicationExecute
}

// Reset resets the calls made to the mocked methods.
func (m *MockFlinkApplicationsApi) Reset() {
	m.lockCreateOrUpdateApplication.Lock()
	m.calls.CreateOrUpdateApplication = nil
	m.lockCreateOrUpdateApplication.Unlock()
	m.lockCreateOrUpdateApplicationExecute.Lock()
	m.calls.CreateOrUpdateApplicationExecute = nil
	m.lockCreateOrUpdateApplicationExecute.Unlock()
	m.lockDeleteApplication.Lock()
	m.calls.DeleteApplication = nil
	m.lockDeleteApplication.Unlock()
	m.lockDeleteApplicationExecute.Lock()
	m.calls.DeleteApplicationExecute = nil
	m.lockDeleteApplicationExecute.Unlock()
	m.lockGetApplication.Lock()
	m.calls.GetApplication = nil
	m.lockGetApplication.Unlock()
	m.lockGetApplicationExecute.Lock()
	m.calls.GetApplicationExecute = nil
	m.lockGetApplicationExecute.Unlock()
	m.lockGetApplicationEvents.Lock()
	m.calls.GetApplicationEvents = nil
	m.lockGetApplicationEvents.Unlock()
	m.lockGetApplicationEventsExecute.Lock()
	m.calls.GetApplicationEventsExecute = nil
	m.lockGetApplicationEventsExecute.Unlock()
	m.lockGetApplicationInstance.Lock()
	m.calls.GetApplicationInstance = nil
	m.lockGetApplicationInstance.Unlock()
	m.lockGetApplicationInstanceExecute.Lock()
	m.calls.GetApplicationInstanceExecute = nil
	m.lockGetApplicationInstanceExecute.Unlock()
	m.lockGetApplicationInstances.Lock()
	m.calls.GetApplicationInstances = nil
	m.lockGetApplicationInstances.Unlock()
	m.lockGetApplicationInstancesExecute.Lock()
	m.calls.GetApplicationInstancesExecute = nil
	m.lockGetApplicationInstancesExecute.Unlock()
	m.lockGetApplications.Lock()
	m.calls.GetApplications = nil
	m.lockGetApplications.Unlock()
	m.lockGetApplicationsExecute.Lock()
	m.calls.GetApplicationsExecute = nil
	m.lockGetApplicationsExecute.Unlock()
	m.lockStartApplication.Lock()
	m.calls.StartApplication = nil
	m.lockStartApplication.Unlock()
	m.lockStartApplicationExecute.Lock()
	m.calls.StartApplicationExecute = nil
	m.lockStartApplicationExecute.Unlock()
	m.lockSuspendApplication.Lock()
	m.calls.SuspendApplication = nil
	m.lockSuspendApplication.Unlock()
	m.lockSuspendApplicationExecute.Lock()
	m.calls.SuspendApplicationExecute = nil
	m.lockSuspendApplicationExecute.Unlock()
}
